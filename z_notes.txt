                        ARRAYS: 

(1) KADANE'S ALGO: Find largest sum subarray (non-empty)

-> Take 2 vars: curr_sum(initially = 0) & max_sum(initially = INT_MIN) & while traversing the array, do curr_sum = max(arr[i], curr_sum + arr[i]), max_sum = max(max_sum, curr_sum) & if sum<0 => sum = 0.

        int kadanes(vector<int>& nums) {
            int max_sum = INT_MIN;
            int curr_sum = 0;

            for (int n : nums) {
                curr_sum = max(n, curr_sum + n);
                max_sum = max(max_sum, curSum);
            }
            return max_sum;
        }

Q1a: Find largest sum subarray (non-empty) in circular array: 
-> int currMax = 0, globalMax = INT_MIN, currMin = 0, globalMin = INT_MAX, total = 0 & while traversing the array: currMax = max(arr[i], currMax+arr[i]), currMin = min(n, currMin+n), globalMax = max(globalMax, currMax), globalMin = min(globalMin, currMin), total+= n; 
    return globalMax>0 ? max(globalMax, total - globalMin) : globalMax ;

(2) SLIDING WINDOW: FIXED SIZE

-> Take 2 pointers: l & r & keep r-l == k (to maintain window size of k) or r-l <=k (to keep window size <=k, if the question requires to) and traverse the array.

Q2a: Check if there exists a subarray of size <= k+1 such that it has a repeating/duplicate no. in it.
->  int l =0, unordered_set<int> st;
    for(int r=0; r<arr.size(); r++){
        if(r-l > k){ 
            st.erase(nums[l]);
            l++;
        }
        if(st.find(nums[r]) != st.end()) return true;
        st.insert(nums[r]);
    }
    return false;

Q2b: Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold
->  int l=0, sum=0, ans=0;
    for(int r=0; r<arr.size(); r++){
        if(r-l+1 > k) sum-= arr[l++];
        sum+= arr[r];
        if(r-l+1 == k && sum/k >= threshold) ans++;
    }
    return ans;

(3) SLIDING WINDOW: VARIABLE SIZE


Q3a: Minimum Size Subarray  with Sum >= target
->  int l=0, sum=0, ans=INT_MAX;
    for(int r=0; r<nums.size(); r++){
        sum+= nums[r];
        while(sum-nums[l] >= target){
            sum-= nums[l];
            l++;
        }
        if(sum>= target) ans = min(ans, r-l+1);
    }
    return ans == INT_MAX ? 0 : ans;

Q3b: Find Length of Longest Substring Without Repeating Characters
->  unordered_set<char> st;
    int ans = 0, l=0;
    loop(r=0 to arr.size()-1) -> if(arr[r](ie, x) is not in set, then insert it, else while(arr[l] != x) => st.erase(arr[l], l++), l++; ans = max(ans, r-l+1)) ;  return ans

Q3c: Given an array of Uppercase Alphabets and an integer k; find the length of longest substring possible with all Alphabets same, if you can change any alphabet to any other alphabet (you can do this upto k times).
-> use hashmap,ie, vector<int> (26,0) freq; int l=0, ans=0; for(int r=0 to arr.size()-1): { freq[s[r]-'A']++, maxFreq = *max_element(freq.begin(), freq.end()),  while(r-l+1 - maxFreq > k) freq[s[l] - 'A']--, l++ ; ans = max(ans, r-l+1)} return ans  : TC: O(26*n)

